#labels bitlyj2.0
#How to roll your own methods.

= Details =

*The details are slim until the API is stable.*

bitlyj2 uses the [http://download.oracle.com/docs/cd/E17476_01/javase/1.5.0/docs/api/org/w3c/dom/package-summary.html native DOM APIs] of the java platform to consume XML payloads that result from bit.ly method invocations. When you implement a bitly method, your method instance receives a [http://download.oracle.com/docs/cd/E17476_01/javase/1.5.0/docs/api/org/w3c/dom/Document.html Document] instance.

== An Example: v3/validate ==
Here's how you roll your own method. The following example would add support for bitly's  [http://code.google.com/p/bitly-api/wiki/ApiDocumentation#/v3/validate validate] method.

{{{
public class Validate extends BitlyMethod<Boolean> {

	public Validate(String user, String apiKey) {
		super("validate", user, apiKey);
	}

	@Override
	public Boolean apply(Document document) {
		String valid = Dom.getTextContent(
			document.getElementsByTagName("valid").item(0));
		return Integer.parseInt(valid) == 1;
	}

}
}}}

*Important:* Note the use of `Dom.getTextContent` instead of calling [http://download.oracle.com/docs/cd/E17476_01/javase/1.5.0/docs/api/org/w3c/dom/Node.html#getTextContent() Node#getTextContent].

Now that you have your own method, you can call it like any other:

{{{
Validate validate = new Validate("notbilytapi", "not_apikey");
boolean isValid = as("bitlyapidemo", "R_0da49e0a9118ff35f52f629d2d71bf07").call(validate);
}}}

Note that you don't need to do any error checking. In bitlyj 2, it's the shortener implementation's job to invoke the remote method, parse its payload, and do basic error checking before ever calling your method implementation. If an I/O error occurs, or bitly responds with and error message (or even garbled data), your method won't be called and the shortener will have thrown and informative exception.